(() => {
  "use strict";
  
  // 최적화 설정
  const CONFIG = {
    CACHE_SIZE: 1000,
    RETRY_COUNT: 3,
    BATCH_SIZE: 50,
    PRELOAD_CACHE: true,
    MULTI_HOOK: true,
    DEBUG_MODE: false
  };
  
  // 번역 데이터 (확장 가능)
  var translation_default = {
    "1": "스킬 1",
    "1000": "흥♪ 드디어 잡았어!",
    "10000": "Roguelike（仮）",
    "SKILL_001": "화염 구슬",
    "SKILL_002": "얼음 화살",
    "SKILL_003": "치유의 빛",
    "ITEM_001": "체력 포션",
    "ITEM_002": "마나 포션",
    "ITEM_003": "힘의 반지",
    "QUEST_001": "첫 번째 모험",
    "QUEST_002": "용을 찾아서",
    "QUEST_003": "마지막 전투",
    "UI_START": "시작하기",
    "UI_CONTINUE": "계속하기",
    "UI_SETTINGS": "설정",
    "UI_EXIT": "종료",
    "DIALOG_001": "안녕하세요, 용사님!",
    "DIALOG_002": "이 세계를 구해주세요.",
    "DIALOG_003": "당신의 모험이 시작됩니다."
  };
  
  // 성능 최적화된 캐시 시스템
  class OptimizedCache {
    constructor(maxSize = CONFIG.CACHE_SIZE) {
      this.cache = new Map();
      this.access = new Map();
      this.maxSize = maxSize;
    }
    
    get(key) {
      if (this.cache.has(key)) {
        this.access.set(key, Date.now());
        return this.cache.get(key);
      }
      return null;
    }
    
    set(key, value) {
      if (this.cache.size >= this.maxSize && !this.cache.has(key)) {
        this.evict();
      }
      this.cache.set(key, value);
      this.access.set(key, Date.now());
    }
    
    evict() {
      let oldest = null;
      let oldestTime = Date.now();
      for (let [key, time] of this.access) {
        if (time < oldestTime) {
          oldestTime = time;
          oldest = key;
        }
      }
      if (oldest) {
        this.cache.delete(oldest);
        this.access.delete(oldest);
      }
    }
  }
  
  // 통계 및 모니터링
  const stats = {
    processed: 0,
    cached: 0,
    errors: 0,
    translated: 0,
    startTime: Date.now()
  };
  
  // 로그 함수
  function log(message, level = 'INFO') {
    if (CONFIG.DEBUG_MODE || level === 'ERROR') {
      console.log(`[${level}] ${message}`);
    }
  }
  
  // 성능 측정 함수
  function measure(func, name) {
    const start = Date.now();
    const result = func();
    const duration = Date.now() - start;
    if (duration > 10) {
      log(`${name} took ${duration}ms`, 'PERF');
    }
    return result;
  }
  
  // 텍스트 처리 함수 (최적화됨)
  function processTextOptimized(rawText, cache, retryCount = 0) {
    try {
      if (!rawText || typeof rawText !== 'string') {
        return rawText;
      }
      
      // TEXT_ID 형식 확인
      if (!rawText.startsWith("TEXT_ID")) {
        return rawText;
      }
      
      // 캐시 확인 (해시 기반)
      const textHash = rawText.substring(0, Math.min(100, rawText.length));
      const cached = cache.get(textHash);
      if (cached) {
        stats.cached++;
        return cached;
      }
      
      // 텍스트 파싱
      const lines = rawText.split('\r\n');
      if (lines.length < 5) {
        log(`Invalid text format: ${lines.length} lines`, 'WARN');
        return rawText;
      }
      
      // 헤더 보존
      const header = lines.slice(0, 4).join('\r\n') + '\r\n';
      let result = header;
      let hasTranslation = false;
      
      // 텍스트 라인 처리 (배치 최적화)
      const textLines = lines.slice(4);
      const processed = [];
      
      for (let i = 0; i < textLines.length; i++) {
        const line = textLines[i];
        if (!line || line.trim() === '') {
          processed.push(line);
          continue;
        }
        
        // 더 정확한 분할 (탭과 공백 모두 처리)
        const parts = line.split(/\s{2,}|\t+/);
        if (parts.length < 1) {
          processed.push(line);
          continue;
        }
        
        const textId = parts[0].trim();
        
        // 번역 적용
        if (translation_default.hasOwnProperty(textId)) {
          const translatedLine = textId + "     " + translation_default[textId] + 
                               (parts.length > 2 ? " " + parts.slice(2).join(" ") : "");
          processed.push(translatedLine);
          hasTranslation = true;
          stats.translated++;
        } else {
          processed.push(line);
        }
      }
      
      result += processed.join('\r\n');
      
      // 번역이 적용된 경우에만 캐시 저장
      if (hasTranslation) {
        cache.set(textHash, result);
        log(`Applied translation for ${processed.length} lines`);
      }
      
      return result;
      
    } catch (error) {
      stats.errors++;
      log(`Error processing text (attempt ${retryCount + 1}): ${error.message}`, 'ERROR');
      
      // 재시도 로직
      if (retryCount < CONFIG.RETRY_COUNT) {
        return processTextOptimized(rawText, cache, retryCount + 1);
      }
      
      log(`Max retries reached, returning original text`, 'ERROR');
      return rawText;
    }
  }
  
  // 메인 Il2Cpp 실행 블록
  Il2Cpp.perform(() => {
    log("Starting optimized Il2Cpp translation system...");
    log(`Unity Version: ${Il2Cpp.unityVersion}`);
    
    // 캐시 시스템 초기화
    const textCache = new OptimizedCache();
    
    // 사전 캐싱 (자주 사용되는 텍스트)
    if (CONFIG.PRELOAD_CACHE) {
      Object.keys(translation_default).forEach(key => {
        textCache.set(`preload_${key}`, translation_default[key]);
      });
      log(`Preloaded ${Object.keys(translation_default).length} common texts`);
    }
    
    try {
      // Assembly 획득
      const img = Il2Cpp.Domain.assembly("Assembly-CSharp").image;
      const coreModule = Il2Cpp.Domain.assembly("UnityEngine.CoreModule").image;
      
      if (!coreModule) {
        throw new Error("UnityEngine.CoreModule not found");
      }
      
      // TextAsset 클래스 및 메서드 획득
      const textAssetClass = coreModule.class("UnityEngine.TextAsset");
      if (!textAssetClass) {
        throw new Error("UnityEngine.TextAsset class not found");
      }
      
      // 멀티 후킹 시스템
      const hookMethods = ["get_text", "get_bytes", "ToString"];
      const hookedMethods = [];
      
      hookMethods.forEach(methodName => {
        try {
          const method = textAssetClass.method(methodName);
          if (method) {
            // 메서드 후킹
            method.implementation = function(...args) {
              let originalResult = null;
              
              try {
                // 원본 메서드 호출
                originalResult = this.method(methodName).invoke(...args);
                
                // null 체크
                if (!originalResult || originalResult.isNull()) {
                  return originalResult;
                }
                
                // 텍스트 처리 (get_text의 경우)
                if (methodName === "get_text" && originalResult.content) {
                  stats.processed++;
                  
                  const processedText = measure(() => 
                    processTextOptimized(originalResult.content, textCache),
                    'Text Processing'
                  );
                  
                  // 텍스트가 변경된 경우에만 새 객체 생성
                  if (processedText !== originalResult.content) {
                    return Il2Cpp.String.from(processedText);
                  }
                }
                
                return originalResult;
                
              } catch (error) {
                stats.errors++;
                log(`Critical error in ${methodName} hook: ${error.message}`, 'ERROR');
                
                // 폴백: 원본 메서드 재호출
                try {
                  return this.method(methodName).invoke(...args);
                } catch (fallbackError) {
                  log(`Fallback failed for ${methodName}: ${fallbackError.message}`, 'ERROR');
                  return originalResult;
                }
              }
            };
            
            hookedMethods.push(methodName);
            log(`Successfully hooked ${methodName}`);
          }
        } catch (error) {
          log(`Failed to hook ${methodName}: ${error.message}`, 'ERROR');
        }
      });
      
      log(`Hooked ${hookedMethods.length} methods: ${hookedMethods.join(', ')}`);
      
      // 성능 모니터링 (주기적 통계 출력)
      let lastLogTime = Date.now();
      const performanceMonitor = setInterval(() => {
        const now = Date.now();
        const uptime = Math.floor((now - stats.startTime) / 1000);
        
        if (stats.processed > 0 && (now - lastLogTime) > 10000) { // 10초마다
          const cacheHitRate = ((stats.cached / Math.max(stats.processed, 1)) * 100).toFixed(1);
          const translationRate = ((stats.translated / Math.max(stats.processed, 1)) * 100).toFixed(1);
          
          log(`[STATS] Uptime: ${uptime}s, Processed: ${stats.processed}, ` +
              `Cache Hit: ${cacheHitRate}%, Translated: ${translationRate}%, ` +
              `Errors: ${stats.errors}, Cache Size: ${textCache.cache.size}`);
          
          lastLogTime = now;
        }
        
        // 메모리 정리 (캐시 크기 제한)
        if (textCache.cache.size > CONFIG.CACHE_SIZE * 0.9) {
          const oldSize = textCache.cache.size;
          while (textCache.cache.size > CONFIG.CACHE_SIZE * 0.7) {
            textCache.evict();
          }
          log(`Cache cleanup: ${oldSize} -> ${textCache.cache.size}`);
        }
        
      }, 5000);
      
      log("Optimized translation system initialized successfully!");
      
      // 시스템 종료 시 정리
      Process.setExceptionHandler((details) => {
        log("System shutting down...");
        clearInterval(performanceMonitor);
        
        // 최종 통계
        const finalUptime = Math.floor((Date.now() - stats.startTime) / 1000);
        log(`[FINAL STATS] Uptime: ${finalUptime}s, Total Processed: ${stats.processed}, ` +
            `Total Translated: ${stats.translated}, Total Errors: ${stats.errors}`);
        
        return false;
      });
      
    } catch (error) {
      log(`Fatal initialization error: ${error.message}`, 'ERROR');
      log(`Stack trace: ${error.stack}`, 'ERROR');
    }
  });
  
  // 전역 에러 핸들러
  Process.setExceptionHandler((details) => {
    log(`Unhandled exception: ${details}`, 'ERROR');
    return false;
  });
  
  log("Optimized translation script loaded successfully!");
  
})();